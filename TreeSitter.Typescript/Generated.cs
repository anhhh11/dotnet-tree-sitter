//----------------------
// <auto-generated>
//     Generated by node_generator.py
//     source: langs-native/tree-sitter-typescript/typescript/src/node-types.json
// </auto-generated>
//----------------------

#nullable enable

using System.Linq;

namespace TreeSitter.Typescript.Nodes {

    public abstract class TypescriptLanguageNode
    {
        public static TypescriptLanguageNode FromNode(TreeSitter.Node node) {
            if (node is null) throw new System.ArgumentNullException(nameof(node));
            if (!node.IsNamed) return new TypescriptLanguageNodeTerminalNode(node);
            switch (node.Kind) {
                case "class_body": return new ClassBody(node);
                case "regex_pattern": return new RegexPattern(node);
                case "class_static_block": return new ClassStaticBlock(node);
                case "required_parameter": return new RequiredParameter(node);
                case "generic_type": return new GenericType(node);
                case "jsx_self_closing_element": return new JsxSelfClosingElement(node);
                case "expression_statement": return new ExpressionStatement(node);
                case "for_in_statement": return new ForInStatement(node);
                case "import_specifier": return new ImportSpecifier(node);
                case "number": return new Number(node);
                case "debugger_statement": return new DebuggerStatement(node);
                case "decorator": return new Decorator(node);
                case "intersection_type": return new IntersectionType(node);
                case "hash_bang_line": return new HashBangLine(node);
                case "tuple_type": return new TupleType(node);
                case "function_type": return new FunctionType(node);
                case "property_signature": return new PropertySignature(node);
                case "program": return new Program(node);
                case "import_clause": return new ImportClause(node);
                case "flow_maybe_type": return new FlowMaybeType(node);
                case "literal_type": return new LiteralType(node);
                case "function_declaration": return new FunctionDeclaration(node);
                case "jsx_closing_element": return new JsxClosingElement(node);
                case "implements_clause": return new ImplementsClause(node);
                case "try_statement": return new TryStatement(node);
                case "pair_pattern": return new PairPattern(node);
                case "optional_type": return new OptionalType(node);
                case "new_expression": return new NewExpression(node);
                case "parenthesized_type": return new ParenthesizedType(node);
                case "jsx_attribute": return new JsxAttribute(node);
                case "arrow_function": return new ArrowFunction(node);
                case "statement_identifier": return new StatementIdentifier(node);
                case "jsx_opening_element": return new JsxOpeningElement(node);
                case "import_require_clause": return new ImportRequireClause(node);
                case "object_type": return new ObjectType(node);
                case "existential_type": return new ExistentialType(node);
                case "optional_parameter": return new OptionalParameter(node);
                case "named_imports": return new NamedImports(node);
                case "namespace_export": return new NamespaceExport(node);
                case "readonly_type": return new ReadonlyType(node);
                case "switch_statement": return new SwitchStatement(node);
                case "array_pattern": return new ArrayPattern(node);
                case "index_type_query": return new IndexTypeQuery(node);
                case "type_predicate": return new TypePredicate(node);
                case "unary_expression": return new UnaryExpression(node);
                case "break_statement": return new BreakStatement(node);
                case "generator_function_declaration": return new GeneratorFunctionDeclaration(node);
                case "property_identifier": return new PropertyIdentifier(node);
                case "while_statement": return new WhileStatement(node);
                case "array_type": return new ArrayType(node);
                case "default_type": return new DefaultType(node);
                case "index_signature": return new IndexSignature(node);
                case "type_annotation": return new TypeAnnotation(node);
                case "enum_body": return new EnumBody(node);
                case "template_type": return new TemplateType(node);
                case "jsx_element": return new JsxElement(node);
                case "this": return new This(node);
                case "asserts": return new Asserts(node);
                case "regex_flags": return new RegexFlags(node);
                case "construct_signature": return new ConstructSignature(node);
                case "nested_identifier": return new NestedIdentifier(node);
                case "rest_type": return new RestType(node);
                case "ambient_declaration": return new AmbientDeclaration(node);
                case "binary_expression": return new BinaryExpression(node);
                case "union_type": return new UnionType(node);
                case "import_alias": return new ImportAlias(node);
                case "variable_declaration": return new VariableDeclaration(node);
                case "extends_clause": return new ExtendsClause(node);
                case "template_string": return new TemplateString(node);
                case "throw_statement": return new ThrowStatement(node);
                case "omitting_type_annotation": return new OmittingTypeAnnotation(node);
                case "nested_type_identifier": return new NestedTypeIdentifier(node);
                case "else_clause": return new ElseClause(node);
                case "glimmer_template": return new GlimmerTemplate(node);
                case "internal_module": return new InternalModule(node);
                case "lookup_type": return new LookupType(node);
                case "mapped_type_clause": return new MappedTypeClause(node);
                case "non_null_expression": return new NonNullExpression(node);
                case "assignment_pattern": return new AssignmentPattern(node);
                case "assignment_expression": return new AssignmentExpression(node);
                case "object_assignment_pattern": return new ObjectAssignmentPattern(node);
                case "method_definition": return new MethodDefinition(node);
                case "public_field_definition": return new PublicFieldDefinition(node);
                case "glimmer_opening_tag": return new GlimmerOpeningTag(node);
                case "continue_statement": return new ContinueStatement(node);
                case "optional_chain": return new OptionalChain(node);
                case "glimmer_closing_tag": return new GlimmerClosingTag(node);
                case "if_statement": return new IfStatement(node);
                case "import_statement": return new ImportStatement(node);
                case "subscript_expression": return new SubscriptExpression(node);
                case "super": return new Super(node);
                case "member_expression": return new MemberExpression(node);
                case "type_alias_declaration": return new TypeAliasDeclaration(node);
                case "empty_statement": return new EmptyStatement(node);
                case "catch_clause": return new CatchClause(node);
                case "export_specifier": return new ExportSpecifier(node);
                case "constructor_type": return new ConstructorType(node);
                case "enum_assignment": return new EnumAssignment(node);
                case "for_statement": return new ForStatement(node);
                case "type_query": return new TypeQuery(node);
                case "class_declaration": return new ClassDeclaration(node);
                case "this_type": return new ThisType(node);
                case "template_substitution": return new TemplateSubstitution(node);
                case "meta_property": return new MetaProperty(node);
                case "conditional_type": return new ConditionalType(node);
                case "module": return new Module(node);
                case "labeled_statement": return new LabeledStatement(node);
                case "opting_type_annotation": return new OptingTypeAnnotation(node);
                case "switch_body": return new SwitchBody(node);
                case "shorthand_property_identifier": return new ShorthandPropertyIdentifier(node);
                case "variable_declarator": return new VariableDeclarator(node);
                case "infer_type": return new InferType(node);
                case "jsx_text": return new JsxText(node);
                case "null": return new Null(node);
                case "jsx_fragment": return new JsxFragment(node);
                case "predefined_type": return new PredefinedType(node);
                case "return_statement": return new ReturnStatement(node);
                case "switch_default": return new SwitchDefault(node);
                case "true": return new True(node);
                case "export_clause": return new ExportClause(node);
                case "as_expression": return new AsExpression(node);
                case "await_expression": return new AwaitExpression(node);
                case "shorthand_property_identifier_pattern": return new ShorthandPropertyIdentifierPattern(node);
                case "formal_parameters": return new FormalParameters(node);
                case "sequence_expression": return new SequenceExpression(node);
                case "augmented_assignment_expression": return new AugmentedAssignmentExpression(node);
                case "statement_block": return new StatementBlock(node);
                case "regex": return new Regex(node);
                case "abstract_method_signature": return new AbstractMethodSignature(node);
                case "type_parameters": return new TypeParameters(node);
                case "parenthesized_expression": return new ParenthesizedExpression(node);
                case "class_heritage": return new ClassHeritage(node);
                case "call_signature": return new CallSignature(node);
                case "constraint": return new Constraint(node);
                case "generator_function": return new GeneratorFunction(node);
                case "abstract_class_declaration": return new AbstractClassDeclaration(node);
                case "array": return new Array(node);
                case "lexical_declaration": return new LexicalDeclaration(node);
                case "type_identifier": return new TypeIdentifier(node);
                case "interface_declaration": return new InterfaceDeclaration(node);
                case "false": return new False(node);
                case "string_fragment": return new StringFragment(node);
                case "jsx_namespace_name": return new JsxNamespaceName(node);
                case "function": return new Function(node);
                case "update_expression": return new UpdateExpression(node);
                case "export_statement": return new ExportStatement(node);
                case "finally_clause": return new FinallyClause(node);
                case "arguments": return new Arguments(node);
                case "type_parameter": return new TypeParameter(node);
                case "accessibility_modifier": return new AccessibilityModifier(node);
                case "override_modifier": return new OverrideModifier(node);
                case "template_literal_type": return new TemplateLiteralType(node);
                case "pair": return new Pair(node);
                case "object": return new Object(node);
                case "object_pattern": return new ObjectPattern(node);
                case "method_signature": return new MethodSignature(node);
                case "satisfies_expression": return new SatisfiesExpression(node);
                case "type_assertion": return new TypeAssertion(node);
                case "type_predicate_annotation": return new TypePredicateAnnotation(node);
                case "string": return new String(node);
                case "class": return new Class(node);
                case "call_expression": return new CallExpression(node);
                case "ternary_expression": return new TernaryExpression(node);
                case "comment": return new Comment(node);
                case "extends_type_clause": return new ExtendsTypeClause(node);
                case "type_arguments": return new TypeArguments(node);
                case "with_statement": return new WithStatement(node);
                case "private_property_identifier": return new PrivatePropertyIdentifier(node);
                case "namespace_import": return new NamespaceImport(node);
                case "computed_property_name": return new ComputedPropertyName(node);
                case "do_statement": return new DoStatement(node);
                case "spread_element": return new SpreadElement(node);
                case "yield_expression": return new YieldExpression(node);
                case "escape_sequence": return new EscapeSequence(node);
                case "enum_declaration": return new EnumDeclaration(node);
                case "undefined": return new Undefined(node);
                case "function_signature": return new FunctionSignature(node);
                case "rest_pattern": return new RestPattern(node);
                case "identifier": return new Identifier(node);
                case "switch_case": return new SwitchCase(node);
                case "import": return new Import(node);
                case "jsx_expression": return new JsxExpression(node);
                case "ERROR": return new ErrorNode(node);
                default: throw new System.ArgumentException("unknown node type: " + node.Kind, nameof(node));
            }
        }

    
        public string Kind { get; set; }

        protected TypescriptLanguageNode(TreeSitter.Node node)
        {
            Kind = node.Kind;
        }
    }
    
    public class TypescriptLanguageNodeTerminalNode : TypescriptLanguageNode
    {
        public TypescriptLanguageNodeTerminalNode(TreeSitter.Node node) : base(node)
        {
        }
    }
    
    public class ErrorNode : TypescriptLanguageNode
    {
        public ErrorNode(TreeSitter.Node node) : base(node)
        {
        }
    }

    public interface IPrimaryType
    {
    }

    public interface Declaration : Statement
    {
    }

    public interface Expression
    {
    }

    public interface Pattern
    {
    }

    public interface PrimaryExpression : Expression
    {
    }

    public interface Statement
    {
    }

    public class AbstractClassDeclaration : TypescriptLanguageNode, Declaration
    {
        public ClassBody Body { get; set; }
        public System.Collections.Generic.List<Decorator> Decorator { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<ClassHeritage> Children { get; set; }
        public AbstractClassDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "abstract_class_declaration");
            
            this.Body = new ClassBody(node.ChildByFieldName("body"));
            this.Decorator = node.ChildrenByFieldName("decorator").Select(x => new Decorator(x)).ToList();
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ClassHeritage(x)).ToList();
        }
    }

    public class AbstractMethodSignature : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<AccessibilityModifier> Children { get; set; }
        public AbstractMethodSignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "abstract_method_signature");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AccessibilityModifier(x)).ToList();
        }
    }

    public class AccessibilityModifier : TypescriptLanguageNode
    {
        public AccessibilityModifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "accessibility_modifier");
            
        }
    }

    public class AmbientDeclaration : TypescriptLanguageNode, Declaration
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public AmbientDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ambient_declaration");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Arguments : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Arguments(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "arguments");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Array : TypescriptLanguageNode, PrimaryExpression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Array(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrayPattern : TypescriptLanguageNode, Pattern
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ArrayPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrayType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<IPrimaryType> Children { get; set; }
        public ArrayType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPrimaryType) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrowFunction : TypescriptLanguageNode, PrimaryExpression
    {
        public TypescriptLanguageNode Body { get; set; }
        public Identifier? Parameter { get; set; }
        public FormalParameters? Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public ArrowFunction(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "arrow_function");
            
            this.Body = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            {
                var tmp = node.ChildByFieldName("parameter");
                this.Parameter = tmp is null ? null : new Identifier(tmp);
            }
            {
                var tmp = node.ChildByFieldName("parameters");
                this.Parameters = tmp is null ? null : new FormalParameters(tmp);
            }
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class AsExpression : TypescriptLanguageNode, Expression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public AsExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "as_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Asserts : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Asserts(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "asserts");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AssignmentExpression : TypescriptLanguageNode, Expression
    {
        public TypescriptLanguageNode Left { get; set; }
        public Expression Right { get; set; }
        public AssignmentExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "assignment_expression");
            
            this.Left = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AssignmentPattern : TypescriptLanguageNode
    {
        public Pattern Left { get; set; }
        public Expression Right { get; set; }
        public AssignmentPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "assignment_pattern");
            
            this.Left = (Pattern) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AugmentedAssignmentExpression : TypescriptLanguageNode, Expression
    {
        public TypescriptLanguageNode Left { get; set; }
        public TypescriptLanguageNodeTerminalNode Operator { get; set; }
        public Expression Right { get; set; }
        public AugmentedAssignmentExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "augmented_assignment_expression");
            
            this.Left = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new TypescriptLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AwaitExpression : TypescriptLanguageNode, Expression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public AwaitExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "await_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BinaryExpression : TypescriptLanguageNode, Expression
    {
        public Expression Left { get; set; }
        public TypescriptLanguageNodeTerminalNode Operator { get; set; }
        public Expression Right { get; set; }
        public BinaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "binary_expression");
            
            this.Left = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new TypescriptLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class BreakStatement : TypescriptLanguageNode, Statement
    {
        public StatementIdentifier? Label { get; set; }
        public BreakStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "break_statement");
            
            {
                var tmp = node.ChildByFieldName("label");
                this.Label = tmp is null ? null : new StatementIdentifier(tmp);
            }
        }
    }

    public class CallExpression : TypescriptLanguageNode, PrimaryExpression
    {
        public TypescriptLanguageNode Arguments { get; set; }
        public Expression Function { get; set; }
        public TypeArguments? TypeArguments { get; set; }
        public CallExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "call_expression");
            
            this.Arguments = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("arguments"))!;
            this.Function = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("function"))!;
            {
                var tmp = node.ChildByFieldName("type_arguments");
                this.TypeArguments = tmp is null ? null : new TypeArguments(tmp);
            }
        }
    }

    public class CallSignature : TypescriptLanguageNode
    {
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public CallSignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "call_signature");
            
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class CatchClause : TypescriptLanguageNode
    {
        public StatementBlock Body { get; set; }
        public TypescriptLanguageNode? Parameter { get; set; }
        public TypeAnnotation? Type { get; set; }
        public CatchClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_clause");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            {
                var tmp = node.ChildByFieldName("parameter");
                this.Parameter = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
        }
    }

    public class Class : TypescriptLanguageNode, PrimaryExpression
    {
        public ClassBody Body { get; set; }
        public System.Collections.Generic.List<Decorator> Decorator { get; set; }
        public TypeIdentifier? Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<ClassHeritage> Children { get; set; }
        public Class(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class");
            
            this.Body = new ClassBody(node.ChildByFieldName("body"));
            this.Decorator = node.ChildrenByFieldName("decorator").Select(x => new Decorator(x)).ToList();
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new TypeIdentifier(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ClassHeritage(x)).ToList();
        }
    }

    public class ClassBody : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ClassBody(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class_body");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ClassDeclaration : TypescriptLanguageNode, Declaration
    {
        public ClassBody Body { get; set; }
        public System.Collections.Generic.List<Decorator> Decorator { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<ClassHeritage> Children { get; set; }
        public ClassDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class_declaration");
            
            this.Body = new ClassBody(node.ChildByFieldName("body"));
            this.Decorator = node.ChildrenByFieldName("decorator").Select(x => new Decorator(x)).ToList();
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ClassHeritage(x)).ToList();
        }
    }

    public class ClassHeritage : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ClassHeritage(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class_heritage");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ClassStaticBlock : TypescriptLanguageNode
    {
        public StatementBlock Body { get; set; }
        public ClassStaticBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class_static_block");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
        }
    }

    public class ComputedPropertyName : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public ComputedPropertyName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "computed_property_name");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConditionalType : TypescriptLanguageNode, IPrimaryType
    {
        public TypescriptLanguageNode Alternative { get; set; }
        public TypescriptLanguageNode Consequence { get; set; }
        public TypescriptLanguageNode Left { get; set; }
        public TypescriptLanguageNode Right { get; set; }
        public ConditionalType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conditional_type");
            
            this.Alternative = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("alternative"))!;
            this.Consequence = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
            this.Left = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class Constraint : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Constraint(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constraint");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConstructSignature : TypescriptLanguageNode
    {
        public FormalParameters Parameters { get; set; }
        public TypeAnnotation? Type { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public ConstructSignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "construct_signature");
            
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class ConstructorType : TypescriptLanguageNode
    {
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode Type { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public ConstructorType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_type");
            
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            this.Type = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class ContinueStatement : TypescriptLanguageNode, Statement
    {
        public StatementIdentifier? Label { get; set; }
        public ContinueStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "continue_statement");
            
            {
                var tmp = node.ChildByFieldName("label");
                this.Label = tmp is null ? null : new StatementIdentifier(tmp);
            }
        }
    }

    public class DebuggerStatement : TypescriptLanguageNode, Statement
    {
        public DebuggerStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "debugger_statement");
            
        }
    }

    public class Decorator : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Decorator(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "decorator");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DefaultType : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public DefaultType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "default_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DoStatement : TypescriptLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public ParenthesizedExpression Condition { get; set; }
        public DoStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "do_statement");
            
            this.Body = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Condition = new ParenthesizedExpression(node.ChildByFieldName("condition"));
        }
    }

    public class ElseClause : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Statement> Children { get; set; }
        public ElseClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "else_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Statement) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EmptyStatement : TypescriptLanguageNode, Statement
    {
        public EmptyStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "empty_statement");
            
        }
    }

    public class EnumAssignment : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public Expression Value { get; set; }
        public EnumAssignment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_assignment");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Value = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class EnumBody : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Name { get; set; }
        public System.Collections.Generic.List<EnumAssignment> Children { get; set; }
        public EnumBody(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_body");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new EnumAssignment(x)).ToList();
        }
    }

    public class EnumDeclaration : TypescriptLanguageNode, Declaration
    {
        public EnumBody Body { get; set; }
        public Identifier Name { get; set; }
        public EnumDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_declaration");
            
            this.Body = new EnumBody(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
        }
    }

    public class ExistentialType : TypescriptLanguageNode, IPrimaryType
    {
        public ExistentialType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "existential_type");
            
        }
    }

    public class ExportClause : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<ExportSpecifier> Children { get; set; }
        public ExportClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "export_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ExportSpecifier(x)).ToList();
        }
    }

    public class ExportSpecifier : TypescriptLanguageNode
    {
        public TypescriptLanguageNode? Alias { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public ExportSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "export_specifier");
            
            {
                var tmp = node.ChildByFieldName("alias");
                this.Alias = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class ExportStatement : TypescriptLanguageNode, Statement
    {
        public Declaration? Declaration { get; set; }
        public System.Collections.Generic.List<Decorator> Decorator { get; set; }
        public String? Source { get; set; }
        public Expression? Value { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ExportStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "export_statement");
            
            {
                var tmp = node.ChildByFieldName("declaration");
                this.Declaration = tmp is null ? null : (Declaration) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Decorator = node.ChildrenByFieldName("decorator").Select(x => new Decorator(x)).ToList();
            {
                var tmp = node.ChildByFieldName("source");
                this.Source = tmp is null ? null : new String(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExpressionStatement : TypescriptLanguageNode, Statement
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ExpressionStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "expression_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExtendsClause : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypeArguments> TypeArguments { get; set; }
        public System.Collections.Generic.List<Expression> Value { get; set; }
        public ExtendsClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "extends_clause");
            
            this.TypeArguments = node.ChildrenByFieldName("type_arguments").Select(x => new TypeArguments(x)).ToList();
            this.Value = node.ChildrenByFieldName("value").Select(x => (Expression) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExtendsTypeClause : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Type { get; set; }
        public ExtendsTypeClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "extends_type_clause");
            
            this.Type = node.ChildrenByFieldName("type").Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FinallyClause : TypescriptLanguageNode
    {
        public StatementBlock Body { get; set; }
        public FinallyClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "finally_clause");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
        }
    }

    public class FlowMaybeType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<IPrimaryType> Children { get; set; }
        public FlowMaybeType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "flow_maybe_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPrimaryType) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ForInStatement : TypescriptLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public TypescriptLanguageNodeTerminalNode? Kind { get; set; }
        public TypescriptLanguageNode Left { get; set; }
        public TypescriptLanguageNodeTerminalNode Operator { get; set; }
        public TypescriptLanguageNode Right { get; set; }
        public Expression? Value { get; set; }
        public ForInStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_in_statement");
            
            this.Body = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            {
                var tmp = node.ChildByFieldName("kind");
                this.Kind = tmp is null ? null : new TypescriptLanguageNodeTerminalNode(tmp);
            }
            this.Left = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new TypescriptLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) TypescriptLanguageNode.FromNode(tmp);
            }
        }
    }

    public class ForStatement : TypescriptLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public TypescriptLanguageNode Condition { get; set; }
        public TypescriptLanguageNode? Increment { get; set; }
        public TypescriptLanguageNode Initializer { get; set; }
        public ForStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_statement");
            
            this.Body = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Condition = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            {
                var tmp = node.ChildByFieldName("increment");
                this.Increment = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Initializer = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("initializer"))!;
        }
    }

    public class FormalParameters : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public FormalParameters(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "formal_parameters");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Function : TypescriptLanguageNode, PrimaryExpression
    {
        public StatementBlock Body { get; set; }
        public Identifier? Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public Function(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class FunctionDeclaration : TypescriptLanguageNode, Declaration
    {
        public StatementBlock Body { get; set; }
        public Identifier Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public FunctionDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_declaration");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class FunctionSignature : TypescriptLanguageNode, Declaration
    {
        public Identifier Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public FunctionSignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_signature");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class FunctionType : TypescriptLanguageNode
    {
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public FunctionType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_type");
            
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            this.ReturnType = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("return_type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class GeneratorFunction : TypescriptLanguageNode, PrimaryExpression
    {
        public StatementBlock Body { get; set; }
        public Identifier? Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public GeneratorFunction(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generator_function");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class GeneratorFunctionDeclaration : TypescriptLanguageNode, Declaration
    {
        public StatementBlock Body { get; set; }
        public Identifier Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public GeneratorFunctionDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generator_function_declaration");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
        }
    }

    public class GenericType : TypescriptLanguageNode, IPrimaryType
    {
        public TypescriptLanguageNode Name { get; set; }
        public TypeArguments TypeArguments { get; set; }
        public GenericType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_type");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.TypeArguments = new TypeArguments(node.ChildByFieldName("type_arguments"));
        }
    }

    public class GlimmerClosingTag : TypescriptLanguageNode
    {
        public GlimmerClosingTag(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "glimmer_closing_tag");
            
        }
    }

    public class GlimmerOpeningTag : TypescriptLanguageNode
    {
        public GlimmerOpeningTag(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "glimmer_opening_tag");
            
        }
    }

    public class GlimmerTemplate : TypescriptLanguageNode, Expression
    {
        public GlimmerClosingTag CloseTag { get; set; }
        public GlimmerOpeningTag OpenTag { get; set; }
        public GlimmerTemplate(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "glimmer_template");
            
            this.CloseTag = new GlimmerClosingTag(node.ChildByFieldName("close_tag"));
            this.OpenTag = new GlimmerOpeningTag(node.ChildByFieldName("open_tag"));
        }
    }

    public class Identifier : TypescriptLanguageNode, Pattern, PrimaryExpression
    {
        public Identifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "identifier");
            
        }
    }

    public class IfStatement : TypescriptLanguageNode, Statement
    {
        public ElseClause? Alternative { get; set; }
        public ParenthesizedExpression Condition { get; set; }
        public Statement Consequence { get; set; }
        public IfStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "if_statement");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : new ElseClause(tmp);
            }
            this.Condition = new ParenthesizedExpression(node.ChildByFieldName("condition"));
            this.Consequence = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
        }
    }

    public class ImplementsClause : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ImplementsClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implements_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Import : TypescriptLanguageNode, PrimaryExpression
    {
        public Import(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "import");
            
        }
    }

    public class ImportAlias : TypescriptLanguageNode, Declaration
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ImportAlias(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "import_alias");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ImportClause : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ImportClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "import_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ImportRequireClause : TypescriptLanguageNode
    {
        public String Source { get; set; }
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public ImportRequireClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "import_require_clause");
            
            this.Source = new String(node.ChildByFieldName("source"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class ImportSpecifier : TypescriptLanguageNode
    {
        public Identifier? Alias { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public ImportSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "import_specifier");
            
            {
                var tmp = node.ChildByFieldName("alias");
                this.Alias = tmp is null ? null : new Identifier(tmp);
            }
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class ImportStatement : TypescriptLanguageNode, Statement
    {
        public String? Source { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ImportStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "import_statement");
            
            {
                var tmp = node.ChildByFieldName("source");
                this.Source = tmp is null ? null : new String(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class IndexSignature : TypescriptLanguageNode
    {
        public TypescriptLanguageNode? IndexType { get; set; }
        public Identifier? Name { get; set; }
        public TypescriptLanguageNodeTerminalNode? Sign { get; set; }
        public TypescriptLanguageNode Type { get; set; }
        public System.Collections.Generic.List<MappedTypeClause> Children { get; set; }
        public IndexSignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "index_signature");
            
            {
                var tmp = node.ChildByFieldName("index_type");
                this.IndexType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            {
                var tmp = node.ChildByFieldName("sign");
                this.Sign = tmp is null ? null : new TypescriptLanguageNodeTerminalNode(tmp);
            }
            this.Type = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new MappedTypeClause(x)).ToList();
        }
    }

    public class IndexTypeQuery : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<IPrimaryType> Children { get; set; }
        public IndexTypeQuery(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "index_type_query");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IPrimaryType) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InferType : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypeIdentifier> Children { get; set; }
        public InferType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "infer_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TypeIdentifier(x)).ToList();
        }
    }

    public class InterfaceDeclaration : TypescriptLanguageNode, Declaration
    {
        public ObjectType Body { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<ExtendsTypeClause> Children { get; set; }
        public InterfaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interface_declaration");
            
            this.Body = new ObjectType(node.ChildByFieldName("body"));
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ExtendsTypeClause(x)).ToList();
        }
    }

    public class InternalModule : TypescriptLanguageNode, Declaration, Expression
    {
        public StatementBlock? Body { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public InternalModule(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "internal_module");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new StatementBlock(tmp);
            }
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class IntersectionType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public IntersectionType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "intersection_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JsxAttribute : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public JsxAttribute(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_attribute");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JsxClosingElement : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public JsxClosingElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_closing_element");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class JsxElement : TypescriptLanguageNode
    {
        public JsxClosingElement CloseTag { get; set; }
        public JsxOpeningElement OpenTag { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public JsxElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_element");
            
            this.CloseTag = new JsxClosingElement(node.ChildByFieldName("close_tag"));
            this.OpenTag = new JsxOpeningElement(node.ChildByFieldName("open_tag"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JsxExpression : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public JsxExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JsxFragment : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public JsxFragment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_fragment");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JsxNamespaceName : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public JsxNamespaceName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_namespace_name");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class JsxOpeningElement : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Attribute { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public TypeArguments? TypeArguments { get; set; }
        public JsxOpeningElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_opening_element");
            
            this.Attribute = node.ChildrenByFieldName("attribute").Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("type_arguments");
                this.TypeArguments = tmp is null ? null : new TypeArguments(tmp);
            }
        }
    }

    public class JsxSelfClosingElement : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Attribute { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public TypeArguments? TypeArguments { get; set; }
        public JsxSelfClosingElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_self_closing_element");
            
            this.Attribute = node.ChildrenByFieldName("attribute").Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("type_arguments");
                this.TypeArguments = tmp is null ? null : new TypeArguments(tmp);
            }
        }
    }

    public class LabeledStatement : TypescriptLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public StatementIdentifier Label { get; set; }
        public LabeledStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "labeled_statement");
            
            this.Body = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Label = new StatementIdentifier(node.ChildByFieldName("label"));
        }
    }

    public class LexicalDeclaration : TypescriptLanguageNode, Declaration
    {
        public TypescriptLanguageNodeTerminalNode Kind { get; set; }
        public System.Collections.Generic.List<VariableDeclarator> Children { get; set; }
        public LexicalDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lexical_declaration");
            
            this.Kind = new TypescriptLanguageNodeTerminalNode(node.ChildByFieldName("kind"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VariableDeclarator(x)).ToList();
        }
    }

    public class LiteralType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public LiteralType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "literal_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LookupType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public LookupType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lookup_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MappedTypeClause : TypescriptLanguageNode
    {
        public TypescriptLanguageNode? Alias { get; set; }
        public TypeIdentifier Name { get; set; }
        public TypescriptLanguageNode Type { get; set; }
        public MappedTypeClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "mapped_type_clause");
            
            {
                var tmp = node.ChildByFieldName("alias");
                this.Alias = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            this.Type = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class MemberExpression : TypescriptLanguageNode, Pattern, PrimaryExpression
    {
        public Expression Object { get; set; }
        public OptionalChain? OptionalChain { get; set; }
        public TypescriptLanguageNode Property { get; set; }
        public MemberExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "member_expression");
            
            this.Object = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("object"))!;
            {
                var tmp = node.ChildByFieldName("optional_chain");
                this.OptionalChain = tmp is null ? null : new OptionalChain(tmp);
            }
            this.Property = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("property"))!;
        }
    }

    public class MetaProperty : TypescriptLanguageNode, PrimaryExpression
    {
        public MetaProperty(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "meta_property");
            
        }
    }

    public class MethodDefinition : TypescriptLanguageNode
    {
        public StatementBlock Body { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public MethodDefinition(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "method_definition");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MethodSignature : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public FormalParameters Parameters { get; set; }
        public TypescriptLanguageNode? ReturnType { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public MethodSignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "method_signature");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Parameters = new FormalParameters(node.ChildByFieldName("parameters"));
            {
                var tmp = node.ChildByFieldName("return_type");
                this.ReturnType = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Module : TypescriptLanguageNode, Declaration
    {
        public StatementBlock? Body { get; set; }
        public TypescriptLanguageNode Name { get; set; }
        public Module(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "module");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : new StatementBlock(tmp);
            }
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class NamedImports : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<ImportSpecifier> Children { get; set; }
        public NamedImports(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "named_imports");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ImportSpecifier(x)).ToList();
        }
    }

    public class NamespaceExport : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public NamespaceExport(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "namespace_export");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NamespaceImport : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public NamespaceImport(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "namespace_import");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class NestedIdentifier : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public NestedIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "nested_identifier");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NestedTypeIdentifier : TypescriptLanguageNode, IPrimaryType
    {
        public TypescriptLanguageNode Module { get; set; }
        public TypeIdentifier Name { get; set; }
        public NestedTypeIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "nested_type_identifier");
            
            this.Module = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("module"))!;
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
        }
    }

    public class NewExpression : TypescriptLanguageNode, Expression
    {
        public Arguments? Arguments { get; set; }
        public PrimaryExpression Constructor { get; set; }
        public TypeArguments? TypeArguments { get; set; }
        public NewExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "new_expression");
            
            {
                var tmp = node.ChildByFieldName("arguments");
                this.Arguments = tmp is null ? null : new Arguments(tmp);
            }
            this.Constructor = (PrimaryExpression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("constructor"))!;
            {
                var tmp = node.ChildByFieldName("type_arguments");
                this.TypeArguments = tmp is null ? null : new TypeArguments(tmp);
            }
        }
    }

    public class NonNullExpression : TypescriptLanguageNode, Pattern, PrimaryExpression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public NonNullExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "non_null_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Object : TypescriptLanguageNode, PrimaryExpression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Object(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "object");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ObjectAssignmentPattern : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Left { get; set; }
        public Expression Right { get; set; }
        public ObjectAssignmentPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "object_assignment_pattern");
            
            this.Left = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class ObjectPattern : TypescriptLanguageNode, Pattern
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ObjectPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "object_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ObjectType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ObjectType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "object_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OmittingTypeAnnotation : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public OmittingTypeAnnotation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "omitting_type_annotation");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OptingTypeAnnotation : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public OptingTypeAnnotation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "opting_type_annotation");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OptionalChain : TypescriptLanguageNode
    {
        public OptionalChain(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "optional_chain");
            
        }
    }

    public class OptionalParameter : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Decorator> Decorator { get; set; }
        public Identifier? Name { get; set; }
        public TypescriptLanguageNode? Pattern { get; set; }
        public TypeAnnotation? Type { get; set; }
        public Expression? Value { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public OptionalParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "optional_parameter");
            
            this.Decorator = node.ChildrenByFieldName("decorator").Select(x => new Decorator(x)).ToList();
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            {
                var tmp = node.ChildByFieldName("pattern");
                this.Pattern = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OptionalType : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public OptionalType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "optional_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OverrideModifier : TypescriptLanguageNode
    {
        public OverrideModifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "override_modifier");
            
        }
    }

    public class Pair : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Key { get; set; }
        public Expression Value { get; set; }
        public Pair(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "pair");
            
            this.Key = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("key"))!;
            this.Value = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class PairPattern : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Key { get; set; }
        public TypescriptLanguageNode Value { get; set; }
        public PairPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "pair_pattern");
            
            this.Key = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("key"))!;
            this.Value = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class ParenthesizedExpression : TypescriptLanguageNode, PrimaryExpression
    {
        public TypeAnnotation? Type { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ParenthesizedExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_expression");
            
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ParenthesizedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PredefinedType : TypescriptLanguageNode, IPrimaryType
    {
        public PredefinedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "predefined_type");
            
        }
    }

    public class Program : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public Program(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "program");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PropertySignature : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public TypeAnnotation? Type { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public PropertySignature(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "property_signature");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PublicFieldDefinition : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public TypeAnnotation? Type { get; set; }
        public Expression? Value { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public PublicFieldDefinition(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "public_field_definition");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReadonlyType : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ReadonlyType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "readonly_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Regex : TypescriptLanguageNode, PrimaryExpression
    {
        public RegexFlags? Flags { get; set; }
        public RegexPattern Pattern { get; set; }
        public Regex(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "regex");
            
            {
                var tmp = node.ChildByFieldName("flags");
                this.Flags = tmp is null ? null : new RegexFlags(tmp);
            }
            this.Pattern = new RegexPattern(node.ChildByFieldName("pattern"));
        }
    }

    public class RequiredParameter : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Decorator> Decorator { get; set; }
        public TypescriptLanguageNode? Name { get; set; }
        public TypescriptLanguageNode? Pattern { get; set; }
        public TypeAnnotation? Type { get; set; }
        public Expression? Value { get; set; }
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public RequiredParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "required_parameter");
            
            this.Decorator = node.ChildrenByFieldName("decorator").Select(x => new Decorator(x)).ToList();
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("pattern");
                this.Pattern = tmp is null ? null : (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) TypescriptLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RestPattern : TypescriptLanguageNode, Pattern
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public RestPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "rest_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RestType : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public RestType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "rest_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReturnStatement : TypescriptLanguageNode, Statement
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ReturnStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "return_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SatisfiesExpression : TypescriptLanguageNode, Expression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public SatisfiesExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "satisfies_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SequenceExpression : TypescriptLanguageNode
    {
        public Expression Left { get; set; }
        public TypescriptLanguageNode Right { get; set; }
        public SequenceExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "sequence_expression");
            
            this.Left = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class SpreadElement : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public SpreadElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "spread_element");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StatementBlock : TypescriptLanguageNode, Statement
    {
        public System.Collections.Generic.List<Statement> Children { get; set; }
        public StatementBlock(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "statement_block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Statement) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class String : TypescriptLanguageNode, PrimaryExpression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public String(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SubscriptExpression : TypescriptLanguageNode, Pattern, PrimaryExpression
    {
        public TypescriptLanguageNode Index { get; set; }
        public Expression Object { get; set; }
        public OptionalChain? OptionalChain { get; set; }
        public SubscriptExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "subscript_expression");
            
            this.Index = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("index"))!;
            this.Object = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("object"))!;
            {
                var tmp = node.ChildByFieldName("optional_chain");
                this.OptionalChain = tmp is null ? null : new OptionalChain(tmp);
            }
        }
    }

    public class SwitchBody : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public SwitchBody(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_body");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchCase : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Statement> Body { get; set; }
        public TypescriptLanguageNode Value { get; set; }
        public SwitchCase(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_case");
            
            this.Body = node.ChildrenByFieldName("body").Select(x => (Statement) TypescriptLanguageNode.FromNode(x)!).ToList();
            this.Value = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class SwitchDefault : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<Statement> Body { get; set; }
        public SwitchDefault(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_default");
            
            this.Body = node.ChildrenByFieldName("body").Select(x => (Statement) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchStatement : TypescriptLanguageNode, Statement
    {
        public SwitchBody Body { get; set; }
        public ParenthesizedExpression Value { get; set; }
        public SwitchStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_statement");
            
            this.Body = new SwitchBody(node.ChildByFieldName("body"));
            this.Value = new ParenthesizedExpression(node.ChildByFieldName("value"));
        }
    }

    public class TemplateLiteralType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TemplateType> Children { get; set; }
        public TemplateLiteralType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "template_literal_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TemplateType(x)).ToList();
        }
    }

    public class TemplateString : TypescriptLanguageNode, PrimaryExpression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TemplateString(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "template_string");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TemplateSubstitution : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TemplateSubstitution(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "template_substitution");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TemplateType : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TemplateType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "template_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TernaryExpression : TypescriptLanguageNode, Expression
    {
        public Expression Alternative { get; set; }
        public Expression Condition { get; set; }
        public Expression Consequence { get; set; }
        public TernaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ternary_expression");
            
            this.Alternative = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("alternative"))!;
            this.Condition = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Consequence = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
        }
    }

    public class ThrowStatement : TypescriptLanguageNode, Statement
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public ThrowStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "throw_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TryStatement : TypescriptLanguageNode, Statement
    {
        public StatementBlock Body { get; set; }
        public FinallyClause? Finalizer { get; set; }
        public CatchClause? Handler { get; set; }
        public TryStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "try_statement");
            
            this.Body = new StatementBlock(node.ChildByFieldName("body"));
            {
                var tmp = node.ChildByFieldName("finalizer");
                this.Finalizer = tmp is null ? null : new FinallyClause(tmp);
            }
            {
                var tmp = node.ChildByFieldName("handler");
                this.Handler = tmp is null ? null : new CatchClause(tmp);
            }
        }
    }

    public class TupleType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TupleType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeAliasDeclaration : TypescriptLanguageNode, Declaration
    {
        public TypeIdentifier Name { get; set; }
        public TypeParameters? TypeParameters { get; set; }
        public TypescriptLanguageNode Value { get; set; }
        public TypeAliasDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_alias_declaration");
            
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameters(tmp);
            }
            this.Value = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class TypeAnnotation : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TypeAnnotation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_annotation");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeArguments : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TypeArguments(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_arguments");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeAssertion : TypescriptLanguageNode, Expression
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TypeAssertion(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_assertion");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeParameter : TypescriptLanguageNode
    {
        public Constraint? Constraint { get; set; }
        public TypeIdentifier Name { get; set; }
        public DefaultType? Value { get; set; }
        public TypeParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter");
            
            {
                var tmp = node.ChildByFieldName("constraint");
                this.Constraint = tmp is null ? null : new Constraint(tmp);
            }
            this.Name = new TypeIdentifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : new DefaultType(tmp);
            }
        }
    }

    public class TypeParameters : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypeParameter> Children { get; set; }
        public TypeParameters(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameters");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TypeParameter(x)).ToList();
        }
    }

    public class TypePredicate : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public TypescriptLanguageNode Type { get; set; }
        public TypePredicate(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_predicate");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Type = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class TypePredicateAnnotation : TypescriptLanguageNode
    {
        public System.Collections.Generic.List<TypePredicate> Children { get; set; }
        public TypePredicateAnnotation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_predicate_annotation");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TypePredicate(x)).ToList();
        }
    }

    public class TypeQuery : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public TypeQuery(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_query");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UnaryExpression : TypescriptLanguageNode, Expression
    {
        public TypescriptLanguageNode Argument { get; set; }
        public TypescriptLanguageNodeTerminalNode Operator { get; set; }
        public UnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unary_expression");
            
            this.Argument = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("argument"))!;
            this.Operator = new TypescriptLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
        }
    }

    public class UnionType : TypescriptLanguageNode, IPrimaryType
    {
        public System.Collections.Generic.List<TypescriptLanguageNode> Children { get; set; }
        public UnionType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "union_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class UpdateExpression : TypescriptLanguageNode, Expression
    {
        public Expression Argument { get; set; }
        public TypescriptLanguageNodeTerminalNode Operator { get; set; }
        public UpdateExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "update_expression");
            
            this.Argument = (Expression) TypescriptLanguageNode.FromNode(node.ChildByFieldName("argument"))!;
            this.Operator = new TypescriptLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
        }
    }

    public class VariableDeclaration : TypescriptLanguageNode, Declaration
    {
        public System.Collections.Generic.List<VariableDeclarator> Children { get; set; }
        public VariableDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variable_declaration");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VariableDeclarator(x)).ToList();
        }
    }

    public class VariableDeclarator : TypescriptLanguageNode
    {
        public TypescriptLanguageNode Name { get; set; }
        public TypeAnnotation? Type { get; set; }
        public Expression? Value { get; set; }
        public VariableDeclarator(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variable_declarator");
            
            this.Name = (TypescriptLanguageNode) TypescriptLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : new TypeAnnotation(tmp);
            }
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (Expression) TypescriptLanguageNode.FromNode(tmp);
            }
        }
    }

    public class WhileStatement : TypescriptLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public ParenthesizedExpression Condition { get; set; }
        public WhileStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "while_statement");
            
            this.Body = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Condition = new ParenthesizedExpression(node.ChildByFieldName("condition"));
        }
    }

    public class WithStatement : TypescriptLanguageNode, Statement
    {
        public Statement Body { get; set; }
        public ParenthesizedExpression Object { get; set; }
        public WithStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "with_statement");
            
            this.Body = (Statement) TypescriptLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Object = new ParenthesizedExpression(node.ChildByFieldName("object"));
        }
    }

    public class YieldExpression : TypescriptLanguageNode, Expression
    {
        public System.Collections.Generic.List<Expression> Children { get; set; }
        public YieldExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "yield_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (Expression) TypescriptLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Comment : TypescriptLanguageNode
    {
        public Comment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "comment");
            
        }
    }

    public class EscapeSequence : TypescriptLanguageNode
    {
        public EscapeSequence(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "escape_sequence");
            
        }
    }

    public class False : TypescriptLanguageNode, PrimaryExpression
    {
        public False(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "false");
            
        }
    }

    public class HashBangLine : TypescriptLanguageNode
    {
        public HashBangLine(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "hash_bang_line");
            
        }
    }

    public class JsxText : TypescriptLanguageNode
    {
        public JsxText(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "jsx_text");
            
        }
    }

    public class Null : TypescriptLanguageNode, PrimaryExpression
    {
        public Null(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "null");
            
        }
    }

    public class Number : TypescriptLanguageNode, PrimaryExpression
    {
        public Number(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "number");
            
        }
    }

    public class PrivatePropertyIdentifier : TypescriptLanguageNode
    {
        public PrivatePropertyIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "private_property_identifier");
            
        }
    }

    public class PropertyIdentifier : TypescriptLanguageNode
    {
        public PropertyIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "property_identifier");
            
        }
    }

    public class RegexFlags : TypescriptLanguageNode
    {
        public RegexFlags(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "regex_flags");
            
        }
    }

    public class RegexPattern : TypescriptLanguageNode
    {
        public RegexPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "regex_pattern");
            
        }
    }

    public class ShorthandPropertyIdentifier : TypescriptLanguageNode
    {
        public ShorthandPropertyIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shorthand_property_identifier");
            
        }
    }

    public class ShorthandPropertyIdentifierPattern : TypescriptLanguageNode
    {
        public ShorthandPropertyIdentifierPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shorthand_property_identifier_pattern");
            
        }
    }

    public class StatementIdentifier : TypescriptLanguageNode
    {
        public StatementIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "statement_identifier");
            
        }
    }

    public class StringFragment : TypescriptLanguageNode
    {
        public StringFragment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_fragment");
            
        }
    }

    public class Super : TypescriptLanguageNode, PrimaryExpression
    {
        public Super(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "super");
            
        }
    }

    public class This : TypescriptLanguageNode, PrimaryExpression
    {
        public This(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "this");
            
        }
    }

    public class ThisType : TypescriptLanguageNode, IPrimaryType
    {
        public ThisType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "this_type");
            
        }
    }

    public class True : TypescriptLanguageNode, PrimaryExpression
    {
        public True(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "true");
            
        }
    }

    public class TypeIdentifier : TypescriptLanguageNode, IPrimaryType
    {
        public TypeIdentifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_identifier");
            
        }
    }

    public class Undefined : TypescriptLanguageNode, Pattern, PrimaryExpression
    {
        public Undefined(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "undefined");
            
        }
    }
}